// crudasm9.cpp - Copyright (C) 2014 Willow Schlanger. All rights reserved.
// ------------------------------------------------------------------------
// crudasm9_w32.exe is the Win32 build of crudasm9 (supports Win32 files).
// crudasm9.exe is the main Win64 build (supports Win32 and Win64 files).
//
// If the macro _WIN32 is defined at build time, we'll include <windows.h>
// and we'll automatically execute coffload64.exe or coffload32.exe if the
// first two bytes of the program being disassembled are MZ or ZM.
//
// We'll then do our regular processing on the generated .DAT file, then
// delete the .DAT file and the other temporary files made by COFFLOAD.
//
// This makes it possible to directly disassemble Win32/Win64 EXEs or DLLs
// when CRUDASM9 is built and used on Windows.
//
// One can also build crudasm9 on Linux or MacOS X. On these platforms, one
// can run crudasm9 on a raw binary for testing purposes, or one can run it
// on a .DAT file generated by manually invoking COFFLOAD32/COFFLOAD64 on a
// Windows system.
// ========================================================================

#ifdef _WIN32
#include <windows.h>
#endif

#include <stddef.h>
#include <string.h>

#ifdef _WIN32
#include "winhelpers.h"
#include <psapi.h>
#endif

#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <iostream>

#include <cctype>
#include <cstdlib>
#include <cstdio>

#include <list>
#include <map>
#include <set>

namespace infrared
{
	typedef unsigned long long U8;
	typedef unsigned int U4;
	typedef unsigned short U2;
	typedef unsigned char U1;

	typedef signed long long S8;
	typedef signed int S4;
	typedef signed short S2;
	typedef signed char S1;
}

// Operating System Abstraction Layer helper class.
class osal_t
{
	osal_t(const osal_t &)  { }		// not allowed
	osal_t &operator=(const osal_t &)  { return *this; }	// not allowed
	
	std::vector<std::string> args;

public:
	osal_t(int argc, char *argv[]);
	std::string arg(size_t num) const;
};

// ------------------------------------------------------------------------

class extended_info_t
{
public:
	// Is this symbol the module's main entrypoint?
	bool is_entrypoint;

	// If this position refers to an exported symbol
	std::string export_name;
	
	// If export_name is not "", then this may contain un undecorated version of export_name, or "".
	std::string export_name_undecorated;
	
	// If set to true, this is the address of an import pointer.
	bool is_import;
	
	// Valid when is_import is true. Note that the requested import symbol may be 'bound', i.e. if
	// it's not a delay-loaded symbol, we may know where it really went to (module, true target symbol
	// name, and the target module's SHA-256 value). See actual_import_t.
	std::string requested_import_symbol;	// starts with a '!' if delay-loaded.

	extended_info_t() :
		is_entrypoint(false),
		is_import(false)
	{
	}
};

class actual_import_t
{
public:
	std::string actual_module_name;
	std::string actual_target_symbol_name;
	std::string actual_module_hash_sha256;
};

class quick_disassembler_t
{
private:
	quick_disassembler_t(const quick_disassembler_t &)  { }
	const quick_disassembler_t &operator=(const quick_disassembler_t &)  { return *this; }

protected:	
	// raw_bits: 0 if we have a DAT/RAW/BIN files (loaded COFFs).
	// else, we have a raw binary image, and raw_bits indicates the bit size (16, 32, or 64).
	int raw_bits;
	
	int actual_bits;

	const char *main_fd;
	long long main_fs;
	const char *raw_fd;
	long long raw_fs;
	const char *bin_fd;
	long long bin_fs;
	
	// Metadata--one byte per loaded image byte. Initialized to all 0s.
	// p - bit 0: =1 if ANY section is here
	// d - bit 1: =1 if data (initialized or uninitalized) is here
	// x - bit 2: =1 if executable
	// w - bit 3: =1 if writable (=0 means read-only)
	// ===
	// bit 4: extended information is available for this position (i.e. there could be an export symbol name for this position, etc.)
	//        in that case, there will be an extended_info_t object available for this position.
	long long metadata_size;
	char *metadata;
	
	std::map<infrared::U8, extended_info_t> ext_metadata_map;
	std::set<infrared::U8> import_set;
	std::map<std::string, actual_import_t> actual_symbol_imports;	// requested name -> info on actual symbol imported, if not delay loaded (i.e. if 'bound')
	
	infrared::U8 origin;
	infrared::U8 entrypoint;
	infrared::U8 start_offset;
	
	std::string main_hash_value;
	std::string main_filename;

public:
	virtual ~quick_disassembler_t();

	quick_disassembler_t(const char *main_fdT, long long main_fsT, int raw_bitsT, const char *raw_fdT, long long raw_fsT, const char *bin_fdT, long long bin_fsT);

	// Returns 0 on success, nonzero in case of error.	
	virtual int init(std::ostream &os);
	
	// Returns 0 on success, nonzero in case of error.	
	virtual int disassemble(std::ostream &os);

protected:
	virtual int decode_insn(infrared::U8 offset) = 0;
	virtual const char *do_disassemble(infrared::U8 offset) = 0;

private:
	void write_U8(std::ostream &os, infrared::U8 value);
};

// ------------------------------------------------------------------------

quick_disassembler_t::~quick_disassembler_t()
{
	delete [] metadata;
}

quick_disassembler_t::quick_disassembler_t(const char *main_fdT, long long main_fsT, int raw_bitsT, const char *raw_fdT, long long raw_fsT, const char *bin_fdT, long long bin_fsT) :
	main_fd(main_fdT),
	main_fs(main_fsT),
	raw_bits(raw_bitsT),
	raw_fd(raw_fdT),
	raw_fs(raw_fsT),
	bin_fd(bin_fdT),
	bin_fs(bin_fsT),
	metadata(NULL),
	metadata_size(0)
{
	metadata_size = (raw_bits == 0) ? raw_fs : main_fs;
	metadata = new char [metadata_size];
}

class CsvReader
{
	CsvReader(const CsvReader &)  { }		// not allowed
	CsvReader &operator=(const CsvReader &)  { return *this; }	// not allowed
	
	const char *csv_begin;
	const char *csv_end;
	
	bool ready;
	bool past_end;
	
	std::vector<std::string> items;

public:
	CsvReader(const char *b, const char *e) :
		csv_begin(b),
		csv_end(e),
		ready(false),
		past_end(false)
	{
	}
	
	virtual ~CsvReader()
	{
	}
	
	std::string get(size_t n)
	{
		if(!ready)
		{
			fetch_line();
		}

		if(past_end)
		{
			return "";
		}
		
		if(n >= items.size())
		{
			return "";
		}
		
		return items[n];
	}
	
	bool at_eof()
	{
		if(past_end)
			return true;
	
		if(!ready)
			fetch_line();
	
		return past_end;
	}
	
	void next()
	{
		if(past_end)
		{
			ready = false;
			return;
		}
	
		if(!ready)
			fetch_line();

		items.clear();
		ready = false;
	}

private:
	void fetch_line()
	{
		items.clear();
	
		if(past_end)
			return;

		// Skip any space characters, such as '\r' or '\n' character(s).
		while(csv_begin != csv_end)
		{
			using namespace std;

			if(!isspace(*csv_begin))
				break;

			++csv_begin;
		}
		
		if(csv_begin == csv_end)
		{
			past_end = true;
			return;
		}
		
		std::string token;
		
		while(csv_begin != csv_end && *csv_begin != '\n' && *csv_begin != '\r')
		{
			if(*csv_begin == '\"')
			{
				token.clear();

				++csv_begin;	// skip first "
				
				while(csv_begin != csv_end && *csv_begin != '\"')
				{
					token += *csv_begin;
					++csv_begin;
				}
				
				if(csv_begin != csv_end)
					++csv_begin;	// skip second "
			}
			else
			if(*csv_begin == ',')
			{
				++csv_begin;

				items.push_back(token);

				token.clear();
			}
			else
			{
				token += *csv_begin;

				++csv_begin;
			}
		}
		
		if(!token.empty())
		{
			items.push_back(token);
		}
		
		ready = true;
	}
};

void quick_disassembler_t::write_U8(std::ostream &os, infrared::U8 value)
{
	char s[128];
	using namespace std;
	s[0] = '\0';
	sprintf(s, "%016llx", value);
	os << s;
}

// Returns 0 on success, nonzero in case of error.
int quick_disassembler_t::disassemble(std::ostream &os)
{
	using namespace std;
	const infrared::U8 size = metadata_size;
	
	os << "; Disassembled by CRUDASM9. Origin: 0x";
	write_U8(os, origin);
	os << ". Entrypoint: loc_";
	write_U8(os, origin + entrypoint);
	os << ".\n";
	
	if(!main_filename.empty())
		os << "; Original filename: " << main_filename << "  (" << actual_bits << " bits)\n";
	
	if(!main_hash_value.empty())
		os << "; Original module SHA-256 hash value: " << main_hash_value << "\n";
	
	infrared::U8 prev_offset = 0xffffffffffffffffULL;
	
	for(infrared::U8 offset = 0; offset < size; )
	{
		if(offset < start_offset)
		{
			os << "\n[Skipped " << start_offset << " byte(s), to first section]\n";
			offset = start_offset;
			continue;
		}
		
		if((metadata[offset] & (1 << 2)) == 0)
		{
			infrared::U8 skipped = 0;
		
			while(offset < size && (metadata[offset] & (1 << 2)) == 0)
			{
				++skipped;
				++offset;
			}
		
			os << "\n[Skipped " << skipped << " non-executable byte(s)]\n";
			
			continue;
		}
		
		// Ok! We have an executable byte.
		int insn_len = decode_insn(offset);
		
		if(insn_len == 0)
		{
			infrared::U8 skipped = 0;
			
			do
			{
				++skipped;
				++offset;

				if(offset >= size)
					break;
			
				insn_len = decode_insn(offset);
				
			}	while(insn_len == 0);
			
			os << "\n[Skipped " << skipped << " unrecognized or invalid opcode byte(s)]\n";
			continue;
		}
		
		// Now let's disassemble this code!
		
		const char *disasm_text = do_disassemble(offset);
		
		if(prev_offset != offset || ((metadata[offset] & (1 << 4)) != 0))
		{
			os << "\n";

			if((metadata[offset] & (1 << 4)) != 0)	// we have extended information here!
			{
				extended_info_t &x = ext_metadata_map[offset];
				
				if(x.is_entrypoint)
					os << "; This is the entrypoint!\n";
				
				if(!x.export_name.empty())
				{
					os << "; This is the location of the following export symbol: " << x.export_name << "\n";
					
					if(!x.export_name_undecorated.empty())
					{
						os << "; Undecorated version of export symbol: " << x.export_name_undecorated << "\n";
					}
				}
			}
		}
		
		os << "loc_";
		write_U8(os, origin + offset);
		os << ":  " << disasm_text << "\n";
		
		offset += insn_len;
		prev_offset = offset;
	}
	
	if(!import_set.empty())
	{
		os << "\n; There are " << import_set.size() << " imported symbol(s).\n";
		
		for(std::set<infrared::U8>::iterator i = import_set.begin(); i != import_set.end(); ++i)
		{
			os << "; ";
			write_U8(os, origin + *i);

			std::string t = ext_metadata_map[*i].requested_import_symbol;
			
			std::string s = t;
			bool delay_loaded = false;
			if(!s.empty() && s[0] == '!')
			{
				s = std::string(++t.begin(), t.end());
				delay_loaded = true;
			}
			
			os << "  " << s;

			if(delay_loaded)
			{
				os << "  (delay-loaded)";
			}
			else
			{
				if(actual_symbol_imports.find(t) != actual_symbol_imports.end())
				{
					actual_import_t &act_imp = actual_symbol_imports[t];

					os << "  -> " << act_imp.actual_target_symbol_name << " (" << act_imp.actual_module_name << " hash: " << act_imp.actual_module_hash_sha256 << ")";
				}
			}
			
			os << "\n";
		}
	}
	
	os << std::endl;

	return 0;	// indicate success
}

// Returns 0 on success, nonzero in case of error.
int quick_disassembler_t::init(std::ostream &os)
{
	// Initialize metadata to all 0s.
	memset(metadata, 0, metadata_size);
	
	actual_bits = raw_bits;
	origin = 0;
	entrypoint = 0;
	start_offset = 0;
	
	main_hash_value.clear();;
	main_filename.clear();
	
	if(actual_bits == 0)
	{
		// Now, let's process the CSV (main_fd and main_fs refer to a CSV .DAT file).
		CsvReader csv(main_fd, main_fd + main_fs);

		if(csv.get(0) != "header")
		{
			os << "error: invalid COFFLOAD .DAT file (first item in the CSV should be \"header\")" << std::endl;
			return 1;
		}
		
		csv.next();	// skip header
		
		bool success = false;
		
		for(; !csv.at_eof(); csv.next())
		{
			if(csv.get(0) == "hash" && csv.get(1) == "sha256")
			{
				main_hash_value = csv.get(2);
				continue;
			}
			
			if(csv.get(0) == "filename" && csv.get(1) == "original")
			{
				main_filename = csv.get(2);
				continue;
			}
		
			if(csv.get(0) == "end" && csv.get(1) == "success")
			{
				success = true;

				continue;
			}
			
			if(csv.get(0) == "bits" && csv.get(1) == "active")
			{
				if(csv.get(2) == "16")
					actual_bits = 16;	// this will probably never happen
				else
				if(csv.get(2) == "32")
					actual_bits = 32;
				else
				if(csv.get(2) == "64")
					actual_bits = 64;
				
				continue;
			}
			
			if(csv.get(0) == "image")
			{
				using namespace std;
				char *ignore = NULL;
			
				if(csv.get(1) == "origin")
				{
					long long x = strtoll(csv.get(2).c_str(), &ignore, 0);

					origin = x;

					continue;
				}

				if(csv.get(1) == "entrypoint")
				{
					long long x = strtoll(csv.get(2).c_str(), &ignore, 0);

					if(x >= 0 && x < metadata_size)
					{
						entrypoint = x;
					
						metadata[entrypoint] |= (1 << 4);	// set extended info flag

						ext_metadata_map[entrypoint].is_entrypoint = true;
					}
					
					continue;
				}

				if(csv.get(1) == "start_offset")
				{
					long long x = strtoll(csv.get(2).c_str(), &ignore, 0);

					start_offset = x;

					continue;
				}
			}
			
			if(csv.get(0) == "import" && csv.get(1) == "offset")
			{
				using namespace std;
				char *ignore = NULL;

				long long pos = strtoll(csv.get(2).c_str(), &ignore, 0);
				std::string symname = csv.get(3);

				if(pos >= 0 && pos < metadata_size && !symname.empty())
				{
					metadata[pos] |= (1 << 4);		// set extended info flag
					
					ext_metadata_map[pos].is_import = true;
					ext_metadata_map[pos].requested_import_symbol = symname;	// begins with a '!' if it's delay-loaded
					
					import_set.insert(pos);			// remember this position!
				}
			
				continue;
			}
			
			if(csv.get(0) == "import" && csv.get(1) == "symbol")
			{
				std::string requested_import_symbol = csv.get(2);
				std::string actual_import_module_name = csv.get(3);
				std::string actual_import_module_hash_sha256 = csv.get(4);
				std::string actual_import_target_symbol_name = csv.get(5);
				
				if(!requested_import_symbol.empty())
				{
					actual_import_t &act_imp = actual_symbol_imports[requested_import_symbol];
					
					act_imp.actual_module_name = actual_import_module_name;
					act_imp.actual_module_hash_sha256 = actual_import_module_hash_sha256;
					act_imp.actual_target_symbol_name = actual_import_target_symbol_name;
				}
			
				continue;
			}
			
			if(csv.get(0) == "export" && csv.get(1) == "symbol")
			{
				using namespace std;
				char *ignore = NULL;

				long long pos = strtoll(csv.get(2).c_str(), &ignore, 0);
				
				if(pos >= 0 && pos < metadata_size)
				{
					metadata[pos] |= (1 << 4);		// set extended info flag
					
					ext_metadata_map[pos].export_name = csv.get(3);

					ext_metadata_map[pos].export_name_undecorated = csv.get(4);
				}
				
				continue;
			}
			
			if(csv.get(0) == "map" && csv.get(1) == "mem_attrs")
			{
				using namespace std;
				char *ignore = NULL;
				long long offset = strtoll(csv.get(3).c_str(), &ignore, 0);
				long long size = strtoll(csv.get(4).c_str(), &ignore, 0);
				
				if(size >= 0)
				{
					infrared::U1 or_mask = 0;
					
					// p - bit 0: =1 if ANY section is here
					// d - bit 1: =1 if data (initialized or uninitalized) is here
					// x - bit 2: =1 if executable
					// w - bit 3: =1 if writable (=0 means read-only)
					std::string wxdp = csv.get(2);
					
					for(size_t i = 0; i < wxdp.size(); ++i)
					{
						if(wxdp[i] == 'p')
							or_mask |= (1 << 0);
						else
						if(wxdp[i] == 'd')
							or_mask |= (1 << 1);
						else
						if(wxdp[i] == 'x')
							or_mask |= (1 << 2);
						else
						if(wxdp[i] == 'w')
							or_mask |= (1 << 3);
					}
					
					for(long long i = 0; i < size; ++i)
					{
						if(offset + i >= metadata_size)
							break;
						
						metadata[offset + i] |= or_mask;
					}
				}
				
				continue;
			}
		}
		
		if(!success)
		{
			os << "error: COFFLOAD .DAT file does not indicate success (it should end with \"end,success\")." << std::endl;
			return 1;
		}
		
		if(actual_bits == 0)
		{
			os << "error: COFFLOAD .DAT file does not correctly indicate the number of bits active." << std::endl;
			return 1;
		}
	}

	return 0;
}

// ------------------------------------------------------------------------

#include "../../x86core/ixdisasm.h"

class crudasm9_quick_disassembler_t :
	public quick_disassembler_t
{
	struct ix_icode_t icode;
	struct ix_decoder_state_t state;
	char disasm_line[4096];

public:
	virtual ~crudasm9_quick_disassembler_t();

	crudasm9_quick_disassembler_t(const char *main_fdT, long long main_fsT, int raw_bitsT, const char *raw_fdT, long long raw_fsT, const char *bin_fdT, long long bin_fsT);

	// Returns 0 on success, nonzero in case of error.	
	virtual int init(std::ostream &os);

	virtual int decode_insn(infrared::U8 offset);

	virtual const char *do_disassemble(infrared::U8 offset);
};

// ------------------------------------------------------------------------

crudasm9_quick_disassembler_t::~crudasm9_quick_disassembler_t()
{
}

crudasm9_quick_disassembler_t::crudasm9_quick_disassembler_t(const char *main_fdT, long long main_fsT, int raw_bitsT, const char *raw_fdT, long long raw_fsT, const char *bin_fdT, long long bin_fsT) :
	quick_disassembler_t(main_fdT, main_fsT, raw_bitsT, raw_fdT, raw_fsT, bin_fdT, bin_fsT)
{
}

int crudasm9_quick_disassembler_t::decode_insn(infrared::U8 offset)
{
	U1 dsz = 0;
	
	if(actual_bits == 16)
		dsz = 0;
	else
	if(actual_bits == 32)
		dsz = 1;
	else
	if(actual_bits == 64)
		dsz = 2;
	else
		return 0;	// internal error!
	
	const U1 *fd = (const U1 *)(main_fd);
	if(raw_bits == 0)
		fd = (const U1 *)(raw_fd);

	const char *status = crudasm_intel_decode(&icode, metadata_size - offset, dsz, (U1 *)(fd) + (size_t)(offset), &state);
	
	if(*status != '\0')
		return 0;	// something went wrong	

	return state.insn_size;
}

const char *crudasm9_quick_disassembler_t::do_disassemble(infrared::U8 offset)
{
	U1 dsz = 0;
	
	if(actual_bits == 16)
		dsz = 0;
	else
	if(actual_bits == 32)
		dsz = 1;
	else
	if(actual_bits == 64)
		dsz = 2;
	else
		return "<unable to disassemble>";

	disasm_line[0] = '\0';

	crudasm_intel_disasm(&icode, origin + offset + (infrared::U8)(state.insn_size), disasm_line, NULL, NULL, dsz);
	
	if(disasm_line[0] != '\0')
		return disasm_line;

	return "<unable to disassemble>";
}

int crudasm9_quick_disassembler_t::init(std::ostream &os)
{
	int result = quick_disassembler_t::init(os);

	if(result != 0)
		return result;
	
	return 0;
}

// ------------------------------------------------------------------------

std::string osal_t::arg(size_t num) const
{
	if(num >= args.size())
		return "";

	return args[num];
}

osal_t::osal_t(int argc, char *argv[])
{
	bool have_args = false;

	// The Windows argv[] are ANSI ant not UTF-8 based. So, for UNICODE
	// filename support on that platform we need to use our helper
	// function.

#ifdef _WIN32
	std::stringstream ignore_msg;
	int ignore_argc = 0;
	int result = process_windows_args(ignore_msg, args, ignore_argc);
	if(result == 0)
	{
		have_args = true;
		
		HANDLE handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, GetCurrentProcessId());

		if(handle != NULL)
		{
			wchar_t wbuf[16384 + 1];
			wbuf[0] = L'\0';

			if(GetModuleFileNameExW(handle, 0, wbuf, 16384) != 0)
			{
				if(wbuf[0] != L'\0')
				{
					args[0] = utf16_to_utf8(wbuf);
				}
			}

			CloseHandle(handle);
		}
	}
#endif

	if(!have_args)
	{
		args.clear();
	
		for(int i = 0; i < argc; ++i)
		{
			args.push_back(argv[i]);
		}
	}
}

// ------------------------------------------------------------------------

int main(int argc, char *argv[])
{
	const char *app_name = "crudasm9";
#ifdef _WIN32
	if(sizeof(void *) * 8 == 32)
		app_name = "crudasm9_w32";
#endif

	osal_t osal(argc, argv);
	
	std::string infile = osal.arg(1);
	std::string outfile = osal.arg(2);
	std::string bits = osal.arg(3);		// optional (may be "")
	int n_bits = 0;				// 0 means unspecified; else it will be 16, 32, or 64
	
	bool need_about = false;
	
	if(bits != "")
	{
		if(bits == "16")
			n_bits = 16;
		else
		if(bits == "32")
			n_bits = 32;
		else
		if(bits == "64")
			n_bits = 64;
		else
		{
			std::cout << app_name << ": bits must be 16, 32, or 64 (got \"" << bits << "\")" << std::endl;
			need_about = true;
		}
	}
	
	if(infile.empty() || outfile.empty())
		need_about = true;
	
	std::cout << app_name << " - Copyright (C) 2011-2014 Willow Schlanger. All rights reserved." << std::endl;

	if(need_about)
	{
		std::cout << "See license_crudasm9.txt or contact willow@willowschlanger.info for details." << std::endl;
		std::cout << "\nVersion: 1.00.00002(beta)" << std::endl;
		std::cout << "\nUsage: " << app_name << " infile outfile [bits]" << std::endl;
		std::cout << "\nExamples:\n  " << app_name << " dosprog.com dosprog.asm 16   (dosprog.com is a 16-bit binary)" << std::endl;
		std::cout << "  " << app_name << " myfile.dat myfile.asm  (myfile.dat is the output from coffload)" << std::endl;

#ifdef _WIN32
		std::cout << "  " << app_name << " myprog.exe myprog.asm  (directly disassemble myprog.exe)" << std::endl;
		std::cout << "  " << app_name << " mylib.dll mylib.asm  (directly disassemble mylib.dll)" << std::endl;
#else
		std::cout << "\n  Note: please see also coffload32.exe and coffload64.exe. Those programs" << std::endl;
		std::cout << "  can be run on a Windows system to produce .dat/.raw/.bin files from an" << std::endl;
		std::cout << "  EXE or DLL. " << app_name << " can then be used to disassemble those files." << std::endl;
#endif
		
		return 0;
	}
	
	if(!file_exists(infile))
	{
		std::cout << app_name << ": error: file does not exist: " << infile << std::endl;
		return 1;
	}
	
	long long main_fs = 0;
	char *main_fd = read_file(infile, &main_fs);
	
	if(main_fd == NULL || main_fs == 0)
	{
		delete [] main_fd;	// it's safe to delete [] a NULL pointer

		std::cout << app_name << ": error: file is empty: " << infile << std::endl;
		return 1;
	}
	
	bool is_dat = false;
	bool is_pe = false;
	const char dat_prefix[] = "header,\"Portable Executable/COFF Binary Load Description File (Version 1.";  // accept version 1.x DAT files
	if(main_fs >= (sizeof(dat_prefix) - 1))
	{
		if(memcmp(main_fd, dat_prefix, (sizeof(dat_prefix) - 1)) == 0)
			is_dat = true;
	}
	
	std::string fn_dat_base;
	
	char *raw_fd = NULL;
	char *bin_fd = NULL;
	long long raw_fs = 0;
	long long bin_fs = 0;

	if(is_dat)
	{
		std::cout << app_name << ": detected a coffload data file" << std::endl;
		std::cout << "read " << get_filename_only(infile) << std::endl;
		
		size_t len = infile.size();
		if(len >= 5)
		{
			std::string extension = make_uppercase(std::string(infile.end() - 4, infile.end()));
			
			if(extension != ".DAT")
			{
				std::cout << app_name << ": error: " << " filename does not end with .dat!" << std::endl;
				return 1;
			}
			
			fn_dat_base = std::string(infile.begin(), infile.end() - 4);
		}
		
		raw_fd = read_file(fn_dat_base + ".raw", &raw_fs);
		bin_fd = read_file(fn_dat_base + ".bin", &bin_fs);
		
		if(raw_fd == NULL || bin_fd == NULL || raw_fs == 0 || bin_fs == 0)
		{
			if(raw_fd == NULL || raw_fs == 0)
				std::cout << app_name << ": error: unable to read " << fn_dat_base << ".raw" << std::endl;
			if(bin_fd == NULL || bin_fs == 0)
				std::cout << app_name << ": error: unable to read " << fn_dat_base << ".bin" << std::endl;
			return 1;
		}
		
		std::cout << fn_dat_base << ".raw" << std::endl;
		std::cout << fn_dat_base << ".bin" << std::endl;
	}
	else
	{
		if(main_fs >= 2)
		{
			if(memcmp(main_fd, "MZ", 2) == 0 || memcmp(main_fd, "ZM", 2) == 0)
				is_pe = true;	// Portable Executable
		}
	}
	
	if(!is_dat && !is_pe)
	{
		if(n_bits == 0)
		{
			std::cout << "Usage: " << app_name << " infile outfile [bits]" << std::endl;
			std::cout << "\n" << app_name << ": 'bits' must be specified on the command-line for raw binary files!" << std::endl;

			delete [] bin_fd;
			delete [] raw_fd;	
			delete [] main_fd;

			return 1;
		}
	
		std::cout << app_name << ": detected a raw " << n_bits << "-bit binary file" << std::endl;
		std::cout << "read " << get_filename_only(infile) << std::endl;
	}
	
	if(is_pe)
	{
		delete [] bin_fd;
		delete [] raw_fd;	
		delete [] main_fd;
		raw_fs = 0;
		bin_fs = 0;
		main_fs = 0;

#ifndef _WIN32
		std::cout << app_name << ": error: attempt to directly disassemble a Portable Executable." << std::endl;
		std::cout << "This is supported only on Win32/Win64 platforms. If you have access to a" << std::endl;
		std::cout << "Windows machine, you can manually use COFFLOAD32.EXE or COFFLOAD64.EXE" << std::endl;
		std::cout << "to load the EXE/DLL in question. Then, run crudasm9 on the resulting" << std::endl;
		std::Cout << "output .dat file." << std::endl;
		return 1;
#else
		// note: fn_dat_base will be "" at this point.
		is_pe = false;
		is_dat = true;
		
		bool ok = true;
		std::wstring w_temp_path;
		std::string temp_location;
		
		if(ok)
		{
			wchar_t data[16384 + 1];
			data[0] = L'\0';
			if(GetTempPathW(16384, data) == 0)
				ok = false;
			else
			if(data[0] != L'\0')
			{
				w_temp_path = data;
			}
			else
				ok = false;
		}
		
		if(ok)
		{
			wchar_t data[16384 + 1];
			data[0] = L'\0';
			if(GetTempFileNameW(w_temp_path.c_str(), utf8_to_utf16(get_filename_only(infile).c_str()).c_str(), 0, data) == 0)
				ok = false;
			else
			if(data[0] != L'\0')
				temp_location = utf16_to_utf8(data);
			else
				ok = false;
		}
		
		std::string rmdir_onexit;
		std::list<std::string> remove_onexit;
		std::string fn_coffload32_exe;
		std::string fn_coffload64_exe;
		
		if(ok)
		{
			// Note: if two instances of crudasm9 are running at the same time, we could get the below error if they
			// both try to create the a temporary directory with the same name, at once. There's probably a better Win32 API
			// call to solve that problem (GetTempDirNameW() ?)
			_wremove(utf8_to_utf16(temp_location.c_str()).c_str());
		
			if(_wmkdir(utf8_to_utf16(temp_location.c_str()).c_str()) != 0)
			{
				std::cout << app_name << ": error: unable to create temporary directory: " << temp_location << std::endl;
				ok = false;
			}
		}
		
		if(ok)
		{
			rmdir_onexit = temp_location;
			
			std::string our_path = directory_from_filename(osal.arg(0));
			
			if(our_path.empty())
			{
				std::cout << app_name << ": error: need to execute coffload32.exe or coffload64.exe\n";
				std::cout << app_name << ":        unable to locate the directory we're running from!\n";
				std::cout << app_name << ":        are we being run from a UNC location or over a network?" << std::endl;
				ok = false;
			}
			else
			{
				if(our_path[our_path.size() - 1] != '\\' && our_path[our_path.size() - 1] != '/')
					our_path += '\\';
			
				fn_coffload32_exe = our_path + "coffload32.exe";
				fn_coffload64_exe = our_path + "coffload64.exe";
			}
		}
		
		std::string prog_to_run;
		
		if(ok)
		{
			if(!file_exists(fn_coffload32_exe))
			{
				std::cout << app_name << ": error: unable to find file: " << fn_coffload32_exe << std::endl;
				ok = false;
			}
			else			
			if(file_exists(fn_coffload64_exe))
			{
				prog_to_run = fn_coffload64_exe;
				
				// If we're the 32-bit program, only support loading 32-bit DLLs/EXEs.
				if(sizeof(void *) * 8 == 32)
					prog_to_run = fn_coffload32_exe;
			}
			else
			{
				fn_coffload64_exe.clear();
				prog_to_run = fn_coffload32_exe;
			}
		}
		
		int exec_result = -1;

		if(ok)
		{
			std::string exec_cmd = "\"" + prog_to_run + "\" \"" + infile + "\" \"" + temp_location + "\\info.txt\" \"" + temp_location + "\"";
			
			// Remove info.txt on exit.
			remove_onexit.push_back(std::string(temp_location + "\\info.txt"));

			//>std::cout << exec_cmd << std::endl;
			PROCESS_INFORMATION pi = {0};
			STARTUPINFOW si = {0};
			si.cb = sizeof(si);
			
			std::cout << std::flush;
			_flushall();
			
			BOOL exec_ok = CreateProcessW(NULL, (LPWSTR)(utf8_to_utf16(exec_cmd.c_str()).c_str()), NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);
			
			if(exec_ok)
			{
				WaitForSingleObject(pi.hProcess, INFINITE);
				
				DWORD dResult = 1;
				GetExitCodeProcess(pi.hProcess, &dResult);
				exec_result = dResult;
				
				CloseHandle(pi.hProcess);
				CloseHandle(pi.hThread);
			}
			else
			{
				std::cout << app_name << ": unable to execute program: " << prog_to_run << std::endl;
				ok = false;
			}
		}
		
		if(ok)
		{
			// Let's make a list of the temporary files COFFLOAD created, so we can clean up when it's time to exit.
			WIN32_FIND_DATAW find_data = {0};
			HANDLE find_handle = FindFirstFileW(utf8_to_utf16((temp_location + "\\out_*.*").c_str()).c_str(), &find_data);
			
			while(find_handle != INVALID_HANDLE_VALUE)
			{
				std::string s = utf16_to_utf8(find_data.cFileName);

				remove_onexit.push_back(std::string(temp_location + "\\" + s));
			
				if(!FindNextFileW(find_handle, &find_data))
				{
					FindClose(find_handle);
					find_handle = INVALID_HANDLE_VALUE;
					break;
				}
			}
		}
		
		if(ok && exec_result != 0)
		{
			std::cout << app_name << ": error " << exec_result << " returned from program: " << prog_to_run << std::endl;
			ok = false;
		}
		
		std::string main_hash;
		
		if(ok)
		{
			// Read the files we're interested in, to main_fd (the .dat file), raw_fd, and bin_fd and delete the original files.
			std::string info_txt = temp_location + "\\info.txt";
			
			long long info_fs;
			char *info_fd = read_file(info_txt, &info_fs);
			
			if(info_fs != 0 && info_fd != NULL)
			{
				CsvReader csv(info_fd, info_fd + info_fs);

				bool success = false;
				
				for(; !csv.at_eof(); csv.next())
				{
					if(csv.get(0) == "status" && csv.get(1) == "success")
					{
						success = true;
						continue;
					}
					
					if(csv.get(0) == "main_hash" && csv.get(1) == "sha256")
					{
						main_hash = csv.get(2);
						continue;
					}
				}
				
				if(!success || main_hash.empty())
				{
					std::cout << app_name << ": error reported by program: " << prog_to_run << std::endl;
					ok = false;
				}
			}
			else
				ok = false;
			
			delete [] info_fd;
		}
		
		if(ok)
		{
			fn_dat_base = temp_location + "\\out_" + main_hash;
			
			main_fd = read_file(fn_dat_base + ".dat", &main_fs);
			raw_fd = read_file(fn_dat_base + ".raw", &raw_fs);
			bin_fd = read_file(fn_dat_base + ".bin", &bin_fs);
			
			if(main_fd == NULL || raw_fd == NULL || bin_fd == NULL || main_fs == 0 || raw_fs == 0 || bin_fs == 0)
			{
				std::cout << app_name << ": load error" << std::endl;
				ok = false;
			}
		}
		
		for(std::list<std::string>::iterator i = remove_onexit.begin(); i != remove_onexit.end(); ++i)
		{
			_wremove(utf8_to_utf16(i->c_str()).c_str());
		}
		
		if(!rmdir_onexit.empty())
		{
			int result_rmdir = _wrmdir(utf8_to_utf16(rmdir_onexit.c_str()).c_str());
			(void) result_rmdir;	// should be 0 if we cleaned everything up properly
		}

		if(!ok)
			return 1;	// indicate error and exit
#endif
	}
	
	// At this point, we either have a raw binary file with a known number of bits, or is_dat is true and we have DAT/RAW/BIN
	// files read into memory that we want to process.
	
	std::ofstream ofasm(outfile.c_str());
	if(ofasm == NULL)
	{
		delete [] bin_fd;
		delete [] raw_fd;	
		delete [] main_fd;
		
		std::cout << app_name << ": error: unable to create file for writing: " << outfile << std::endl;		

		return 1;
	}
	
	crudasm9_quick_disassembler_t crudasm_qdis(main_fd, main_fs, (is_dat) ? 0 : n_bits, raw_fd, raw_fs, bin_fd, bin_fs);
	
	int result = crudasm_qdis.init(std::cout);
	
	if(result != 0)
	{
		delete [] bin_fd;
		delete [] raw_fd;	
		delete [] main_fd;
		
		return 0;
	}
	
	result = crudasm_qdis.disassemble(ofasm);
	
	if(result != 0)
	{
		std::cout << app_name << ": error: unable to disassemble" << std::endl;
	
		delete [] bin_fd;
		delete [] raw_fd;	
		delete [] main_fd;
		
		return 0;
	}
	
	delete [] bin_fd;
	delete [] raw_fd;	
	delete [] main_fd;
	
	std::cout << "Disassembly output: " << outfile << std::endl;

	return 0;
}
